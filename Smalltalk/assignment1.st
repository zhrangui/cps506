Object subclass: #Blocks	instanceVariableNames: 'column row type points orient tempP frozen'	classVariableNames: ''	poolDictionaries: ''	category: 'Assignment'!!Blocks commentStamp: '<historical>' prior: 0!Creates the super class of the blocks with the most general methods!!Blocks methodsFor: 'initialize' stamp: 'HajeKanda 10/10/2017 02:10'!initializex: a y: b	"initialize the placement of the focal block and whether or not its frozen"	row := b.	column := a.	frozen := false.	orient := 1.	! !!Blocks methodsFor: 'move' stamp: 'HajeKanda 10/10/2017 01:58'!left	"moves the block leftwards"	| coord x y array |	array := OrderedCollection new.	1 to: points size do: [ :i | 		coord := points at: i.		x := coord at: 2.		x := x - 1.		y := coord at: 1.		array add: (Array with: y with: x) ].	self setTempP: array! !!Blocks methodsFor: 'move' stamp: 'HajeKanda 10/10/2017 01:50'!down	"moves the block down by one"	| coord x y array |	array := OrderedCollection new.	1 to: points size do: [ :i | 		coord := points at: i.		x := coord at: 1.		x := x + 1.		y := coord at: 2.		array add: (Array with: x with: y) ].	self setTempP: array! !!Blocks methodsFor: 'move' stamp: 'HajeKanda 10/10/2017 01:59'!right	"moves the block to the right"	| coord x y array |	array := OrderedCollection new.	1 to: points size do: [ :i | 		coord := points at: i.		x := coord at: 2.		x := x + 1.		y := coord at: 1.		array add: (Array with: y with: x) ].	self setTempP: array! !!Blocks methodsFor: 'move' stamp: 'HajeKanda 10/10/2017 02:00'!tempDown	"moves the block down one temporarily using the temporary points"	| coord x y array |	array := OrderedCollection new.	1 to: tempP size do: [ :i | 		coord := tempP at: i.		x := coord at: 1.		x := x + 1.		y := coord at: 2.		array add: (Array with: x with: y) ].	self setTempP: array! !!Blocks methodsFor: 'accessor' stamp: 'HajeKanda 10/10/2017 01:54'!getType"returns the type of block"	^ type! !!Blocks methodsFor: 'accessor' stamp: 'HajeKanda 10/10/2017 01:53'!getOrient	"returns the orientation number of the block"	^ orient! !!Blocks methodsFor: 'accessor' stamp: 'HajeKanda 10/10/2017 01:54'!getTempP"returns the temporary points"	^ tempP! !!Blocks methodsFor: 'accessor' stamp: 'HajeKanda 10/10/2017 01:54'!getPoints	"returns the all of the points of the block"	^ points! !!Blocks methodsFor: 'accessor' stamp: 'HajeKanda 10/10/2017 01:49'!getFro"returns the state of the block (is it frozen in place or not)"	^ frozen! !!Blocks methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 01:57'!setTempP: p"sets the array of temporary points"	tempP := p! !!Blocks methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 01:57'!setPoints: p"sets the array of points"	points := p! !!Blocks methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 01:56'!setFro"freezes the block"	frozen := true! !Blocks subclass: #B	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Assignment'!!B commentStamp: '<historical>' prior: 0!Creates the subclass block B with more specific methods!!B methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:05'!move: dir	"chooses the correct action and deals accordingly"	dir asString asSymbol == 'l' asSymbol		ifTrue: [ self left ].	dir asString asSymbol == 'r' asSymbol		ifTrue: [ self right ].	dir asString asSymbol == 'L' asSymbol		ifTrue: [ orient asString asSymbol == '1' asSymbol				ifTrue: [ orient := 5 ].			orient asString asSymbol == '1' asSymbol				ifFalse: [ self rotate: orient - 1 ] ].	dir asString asSymbol == 'R' asSymbol		ifTrue: [ orient asString asSymbol == '4' asSymbol				ifTrue: [ orient := 0 ].			orient asString asSymbol == '4' asSymbol				ifFalse: [ self rotate: orient + 1 ] ].	dir asString asSymbol == '.' asSymbol		ifTrue: [ super down ].	dir asString asSymbol == '.t' asSymbol		ifTrue: [ super tempDown ].	dir asString asSymbol == 'up' asSymbol		ifTrue: [ self up ]! !!B methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:06'!rotate: cw	"rotates the block according to its orientation"	| p1 p2 p3 p4 coord |	coord  := points at: 1.	column := coord at: 1.	row := coord at: 2.	p1 := Array with: column with: row.	1 == cw		ifTrue: [ p2 := Array with: column with: row + 1.			p3 := Array with: column with: row - 1.			p4 := Array with: column - 1 with: row - 1.			orient := 1 asNumber ].	2 == cw		ifTrue: [ p2 := Array with: column - 1 with: row + 1.			p3 := Array with: column + 1 with: row.			p4 := Array with: column - 1 with: row.			orient := 2 asNumber ].	3 == cw		ifTrue: [ p2 := Array with: column with: row + 1.			p3 := Array with: column with: row - 1.			p4 := Array with: column + 1 with: row + 1.			orient := 3 asNumber ].	4 == cw		ifTrue: [ p2 := Array with: column + 1 with: row - 1.			p3 := Array with: column + 1 with: row.			p4 := Array with: column - 1 with: row.			orient := 4 asNumber ].	self		setTempP:			(Array				with: p1				with: p2				with: p3				with: p4).	^ points! !!B methodsFor: 'initialize' stamp: 'HajeKanda 10/10/2017 02:03'!initializex: b y: a"creates the block"	| p1 p2 p3 p4 |	super initializex: a y: b.	type := 'b'.	p1 := Array with: a with: b.	p2 := Array with: a with: b + 1.	p3 := Array with: a with: b - 1.	p4 := Array with: a - 1 with: b - 1.	self		setTempP:			(Array				with: p1				with: p2				with: p3				with: p4).	^ points! !Object subclass: #Board	instanceVariableNames: 'rows cols cell numBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Assignment'!!Board commentStamp: 'HajeKanda 10/11/2017 10:07' prior: 0!Creates the board and all of its components for the game!!Board methodsFor: 'printing' stamp: 'HajeKanda 10/10/2017 02:14'!printOn: stream"prints on the stream the board and the number of blocks"	| string text |	stream cr.	1 to: cols asInteger do: [ :j | 		string := self getRow: 1 col: j.		stream nextPutAll: string asString ].	text := ' piece'.	stream		nextPutAll: ' ';		nextPutAll: numBlock asString;		nextPutAll: (text asPluralBasedOn: numBlock) asString;		cr.	2 to: rows asInteger do: [ :i | 		1 to: cols asInteger do: [ :j | 			string := self getRow: i col: j.			stream nextPutAll: string ].		stream cr ].	stream flush! !!Board methodsFor: 'initialize' stamp: 'HajeKanda 10/10/2017 02:13'!boardComponents: list	"defines the dimensions of the board and then creates it"	| row column temp |	temp := list first.	row := (temp at: 3) asNumber + 1.	column := (temp at: 2) asNumber + 2.	numBlock := 0.	self createrows: row cols: column! !!Board methodsFor: 'initialize' stamp: 'HajeKanda 9/28/2017 02:58'!createrows: r cols: c"Declares the rows and columns of the board"| board |cell := Dictionary new. board := cell.rows := r.cols := c. ^board. ! !!Board methodsFor: 'accessor' stamp: 'HajeKanda 10/10/2017 02:14'!getRow	"returns the number of rows (including bottom row)"	^ rows! !!Board methodsFor: 'accessor' stamp: 'HajeKanda 10/10/2017 02:13'!getCol"returns the number of columns (including borders)"	^ cols! !!Board methodsFor: 'accessor' stamp: 'HajeKanda 10/10/2017 02:14'!getRow: r col: c	"returns the object at the position or ' '' is empty "	| point temp |	point := Array with: r with: c.	temp := nil.	1 == c | (cols == c)		ifTrue: [ temp := '|' ].	rows == r		ifTrue: [ temp := '-' ].	rows == r & (1 == c | (cols == c))		ifTrue: [ temp := '+' ].	temp == nil		ifTrue: [ ^ cell at: point ifAbsent: [ ' ' ] ].	temp == nil		ifFalse: [ ^ temp ]! !!Board methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:14'!increaseNumBlock	"increases the block number count"	numBlock := numBlock + 1! !!Board methodsFor: 'modifier' stamp: 'HajeKanda 10/5/2017 18:15'!put: element row: r col: c"inserts an element inside a cell"| point |point  := Array with: r with: c.cell at: point put: element. ! !Blocks subclass: #C	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Assignment'!!C commentStamp: 'HajeKanda 10/11/2017 10:06' prior: 0!Creates the subclass block C with more specific methods!!C methodsFor: 'initialize' stamp: 'HajeKanda 10/10/2017 02:08'!initializex: b y: a	"creates the block"	| p1 p2 p3 p4 |	super initializex: a y: b.	type := 'c'.	p1 := Array with: a with: b.	p2 := Array with: a with: b + 1.	p3 := Array with: a with: b - 1.	p4 := Array with: a with: b + 2.	self		setTempP:			(Array				with: p1				with: p2				with: p3				with: p4).	^ points! !!C methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:05'!move: dir	"chooses the correct action and deals accordingly"	dir asString asSymbol == 'l' asSymbol		ifTrue: [ self left ].	dir asString asSymbol == 'r' asSymbol		ifTrue: [ self right ].	dir asString asSymbol == 'L' asSymbol		ifTrue: [ orient asString asSymbol == '1' asSymbol				ifTrue: [ orient := 5 ].			orient asString asSymbol == '1' asSymbol				ifFalse: [ self rotate: orient - 1 ] ].	dir asString asSymbol == 'R' asSymbol		ifTrue: [ orient asString asSymbol == '4' asSymbol				ifTrue: [ orient := 0 ].			orient asString asSymbol == '4' asSymbol				ifFalse: [ self rotate: orient + 1 ] ].	dir asString asSymbol == '.' asSymbol		ifTrue: [ super down ].	dir asString asSymbol == '.t' asSymbol		ifTrue: [ super tempDown ].	dir asString asSymbol == 'up' asSymbol		ifTrue: [ self up ]! !!C methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:07'!rotate: cw	"rotates the block according to its orientation"	| p1 p2 p3 p4 coord |	coord := points at: 1.	column := coord at: 1.	row := coord at: 2.	p1 := Array with: column with: row.	1 == cw		ifTrue: [ p2 := Array with: column with: row + 1.			p3 := Array with: column with: row - 1.			p4 := Array with: column with: row + 2.			orient := 1 asInteger ].	2 == cw		ifTrue: [ p2 := Array with: column + 1 with: row.			p3 := Array with: column - 1 with: row.			p4 := Array with: column + 2 with: row.			orient := 2 asNumber ].	3 == cw		ifTrue: [ p2 := Array with: column with: row + 1.			p3 := Array with: column with: row - 1.			p4 := Array with: column with: row - 2.			orient := 3 asNumber ].	4 == cw		ifTrue: [ p2 := Array with: column - 1 with: row.			p3 := Array with: column - 2 with: row.			p4 := Array with: column + 1 with: row.			orient := 4 asNumber ].	self		setTempP:			(Array				with: p1				with: p2				with: p3				with: p4).	^ points! !Object subclass: #Dice	instanceVariableNames: 'index list'	classVariableNames: ''	poolDictionaries: ''	category: 'Assignment'!!Dice commentStamp: 'HajeKanda 10/11/2017 10:07' prior: 0!Creates the dice of the game and keeps track of its indices and such!!Dice methodsFor: 'modifier' stamp: 'HajeKanda 10/6/2017 01:01'!indexIncrease	"increases the index number by one"	((index asString)asSymbol) == 				(((list size) asString)asSymbol) ifTrue: [  index := 0 ].	((index asString)asSymbol) == 				(((list size) asString)asSymbol) ifFalse: [  index := ((index asNumber)+1) ].			! !!Dice methodsFor: 'accessor' stamp: 'HajeKanda 10/5/2017 18:06'!list	"returns the list of dice "^list.! !!Dice methodsFor: 'accessor' stamp: 'HajeKanda 10/5/2017 22:34'!getIndex	"returns the index of which number we are on on the die"^index.! !!Dice methodsFor: 'intialize' stamp: 'HajeKanda 10/5/2017 23:19'!initialize: line"accepts Collection(dice, 1, 2,3, 4)"	|array|	array := OrderedCollection new.		"seperates the dice components from the command"	2 to: (line size) do: [ :i|				array addLast: (line at: i).		 ].	list := array. "saving the dice numbers so it can be used at a later time without getting lost"	index := 1.! !Blocks subclass: #G	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Assignment'!!G commentStamp: 'HajeKanda 10/11/2017 10:06' prior: 0!Creates the subclass block G with more specific methodsS!!G methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:05'!move: dir	"chooses the correct action and deals accordingly"		dir asString asSymbol == 'l' asSymbol		ifTrue: [ self left ].	dir asString asSymbol == 'r' asSymbol		ifTrue: [ self right ].	dir asString asSymbol == 'L' asSymbol		ifTrue: [ orient asString asSymbol == '1' asSymbol				ifTrue: [ orient := 5 ].			orient asString asSymbol == '1' asSymbol				ifFalse: [ self rotate: orient - 1 ] ].	dir asString asSymbol == 'R' asSymbol		ifTrue: [ orient asString asSymbol == '4' asSymbol				ifTrue: [ orient := 0 ].			orient asString asSymbol == '4' asSymbol				ifFalse: [ self rotate: orient + 1 ] ].	dir asString asSymbol == '.' asSymbol		ifTrue: [ super down ].	dir asString asSymbol == '.t' asSymbol		ifTrue: [ super tempDown ].	dir asString asSymbol == 'up' asSymbol		ifTrue: [ self up ]! !!G methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:07'!rotate: cw	"rotates the block according to its orientation"	| p1 p2 p3 p4 coord |	coord := points at: 1.	column := coord at: 1.	row := coord at: 2.	p1 := Array with: column with: row.	1 == cw		ifTrue: [ p2 := Array with: column with: row - 1.			p3 := Array with: column - 1 with: row.			p4 := Array with: column - 1 with: row + 1.			orient := 1 asInteger ].	2 == cw		ifTrue: [ p2 := Array with: column - 1 with: row.			p3 := Array with: column with: row + 1.			p4 := Array with: column + 1 with: row + 1.			orient := 2 asInteger ].	3 == cw		ifTrue: [ p2 := Array with: column with: row + 1.			p3 := Array with: column + 1 with: row.			p4 := Array with: column + 1 with: row - 1.			orient := 3 asInteger ].	4 == cw		ifTrue: [ p2 := Array with: column - 1 with: row.			p3 := Array with: column with: row + 1.			p4 := Array with: column + 1 with: row + 1.			orient := 4 asInteger ].	self		setTempP:			(Array				with: p1				with: p2				with: p3				with: p4).	^ points! !!G methodsFor: 'initialize' stamp: 'HajeKanda 10/10/2017 02:11'!initializex: b y: a	"creates the block"	| p1 p2 p3 p4 |	super initializex: a y: b.	type := 'g'.	p1 := Array with: a with: b.	p2 := Array with: a with: b - 1.	p3 := Array with: a - 1 with: b.	p4 := Array with: a - 1 with: b + 1.	self		setTempP:			(Array				with: p1				with: p2				with: p3				with: p4).	^ points! !Object subclass: #Game	instanceVariableNames: 'board commands dice currentBlock diceIndice startNumber puCurrent movesStat'	classVariableNames: ''	poolDictionaries: ''	category: 'Assignment'!!Game commentStamp: 'HajeKanda 10/11/2017 10:08' prior: 0!Creates the actual game, how to interpert the commands, and creates the game board and dice !!Game methodsFor: 'blockMutating' stamp: 'HajeKanda 10/10/2017 02:26'!placePowerUp	"places the powerup on the screen"	| coord x temp |	coord := puCurrent getList.	1 to: coord size do: [ :i | 		x := coord at: i.		temp := board getRow: (x at: 1) col: (x at: 2).		temp asSymbol == ' ' asSymbol			ifTrue: [ board put: 'x' row: (x at: 1) col: (x at: 2) ] ]! !!Game methodsFor: 'blockMutating' stamp: 'HajeKanda 10/8/2017 10:21'!rotation	"will figure out how much to rotate the block by"|num list rot|num := ((dice getIndex) asNumber).list := (dice list).rot := ((list at: num)asNumber).((rot asNumber) > 4) ifTrue: 	[ 	rot := ((rot asNumber) -4).].currentBlock rotate: rot.dice indexIncrease.	! !!Game methodsFor: 'blockMutating' stamp: 'HajeKanda 10/10/2017 02:22'!drop	"will move the block down until it hits either the bottom or another block"	currentBlock down.	[ self ifFilledRow asSymbol == 'f' asSymbol ] whileFalse: [ currentBlock down ]! !!Game methodsFor: 'blockMutating' stamp: 'HajeKanda 10/10/2017 02:26'!placeBlock: block at: points	"places a block onto the grid"	| coord |	board increaseNumBlock.	1 to: points size do: [ :i | 		coord := points at: i.		board put: block getType row: (coord at: 1) col: (coord at: 2) ].	currentBlock notNil & puCurrent notNil		ifTrue: [ self checkIfPowerUp ]! !!Game methodsFor: 'blockMutating' stamp: 'HajeKanda 10/10/2017 02:20'!create: class list: array	"create an instance of the desired block and makes it the current block that were working with"	| block a b |	a := (array at: 2) asNumber.		b := (array at: 3) asNumber.		block := class new.		block initializex: a y: b.		currentBlock := block.		self ifFilledRow.	^ block! !!Game methodsFor: 'clear' stamp: 'HajeKanda 10/10/2017 02:23'!fullRowClear	"clears the entire row if it is all taken up by blocks"	| key count currentRow deletenator |	deletenator := false.	currentRow := board getRow - 1.	key := false.	[ key ]		whileFalse: [ 			count := 0.			1 to: board getCol do: [ :i | 				(board getRow: currentRow col: i) asString asSymbol == ' ' asSymbol					ifTrue: [ count := count + 1 ] ].			count asString asSymbol == '0' asSymbol				ifTrue: [ key := true.					deletenator := true ].			currentRow asString asSymbol == '0' asSymbol				ifTrue: [ key := true ].			(count asString asSymbol == '0' asSymbol | currentRow asString asSymbol) == '0' asSymbol				ifFalse: [ currentRow := currentRow - 1 ] ].	deletenator		ifTrue: [ self shift: currentRow ]! !!Game methodsFor: 'clear' stamp: 'HajeKanda 10/10/2017 02:27'!powerClear	"will clear the bottom most row one away from being full if powerup is landed on "	| key count currentRow deletenator |	currentRow := board getRow - 1.	key := false.	deletenator := false.	[ key ]		whileFalse: [			count := 0.			1 to: board getCol do: [ :i | 				(board getRow: currentRow col: i) asString asSymbol == ' ' asSymbol					ifTrue: [ count := count + 1 ] ].			count asString asSymbol == '1' asSymbol				ifTrue: [ key := true.					deletenator := true ].			currentRow asString asSymbol == '0' asSymbol				ifTrue: [ key := true ].			(count asString asSymbol == '1' asSymbol | currentRow asString asSymbol) == '0' asSymbol				ifFalse: [ currentRow := currentRow - 1 ] ].	deletenator		ifTrue: [ self shift: currentRow ]! !!Game methodsFor: 'command' stamp: 'HajeKanda 10/10/2017 02:22'!dice	"creates the block were working with and then sends it to find the orientation"	| blockNum index |	index := dice getIndex.		blockNum := dice list at: index.	1 asString asSymbol == blockNum asString asSymbol		ifTrue: [ self create: Y list: (Array with: Y with: startNumber with: 1) ].	2 asString asSymbol == blockNum asString asSymbol		ifTrue: [ self create: R list: (Array with: R with: startNumber with: 1) ].	3 asString asSymbol == blockNum asString asSymbol		ifTrue: [ self create: G list: (Array with: G with: startNumber with: 1) ].	4 asString asSymbol == blockNum asString asSymbol		ifTrue: [ self create: B list: (Array with: B with: startNumber with: 1) ].	5 asString asSymbol == blockNum asString asSymbol		ifTrue: [ self create: O list: (Array with: O with: startNumber with: 1) ].	6 asString asSymbol == blockNum asString asSymbol		ifTrue: [ self create: P list: (Array with: P with: startNumber with: 1) ].	7 asString asSymbol == blockNum asString asSymbol		ifTrue: [ self create: C list: (Array with: C with: startNumber with: 1) ].	dice indexIncrease.	self rotation.	self isTop! !!Game methodsFor: 'command' stamp: 'HajeKanda 10/10/2017 02:25'!move: list	"will choose how to deal with move appropriately."	| temp action |	2 to: list size do: [ :i | 		temp := list at: i.		1 to: temp size do: [ :j | 			action := temp at: j.			action asString asSymbol == '+' asSymbol				ifTrue: [ self drop.					currentBlock setFro ].			action asString asSymbol == '+' asSymbol				ifFalse: [ action asString asSymbol == '.' asSymbol						ifTrue: [ currentBlock move: '.'.							self ifFilledRow asString asSymbol == 'f' asSymbol								ifTrue: [ currentBlock setFro ] ].					action asString asSymbol == '.' asSymbol						ifFalse: [ currentBlock getPoints notNil								ifTrue: [ currentBlock move: action.									self isTop.									self ifFilledRow ] ] ].			currentBlock getFro				ifTrue: [ self placeBlock: currentBlock at: currentBlock getPoints.					self dice.					self fullRowClear ] ] ]! !!Game methodsFor: 'command' stamp: 'HajeKanda 10/10/2017 02:25'!commands	"process the rest of the commands"	| line test size |	size := commands size.	2 to: size do: [ :i | 		line := commands at: i.		test := (line at: 1) asSymbol.		'powerup' asSymbol == test			ifTrue: [ 				puCurrent isNil					ifTrue: [ puCurrent := PowerUp new.						puCurrent := puCurrent startList ].				puCurrent initializex: (line at: 2) asNumber + 1 y: board getRow - (line at: 3) asNumber.				self placePowerUp ].		dice notNil			ifTrue: [ 'moves' asSymbol == test					ifTrue: [ movesStat := true.						line size asString asSymbol == '1' asSymbol							ifFalse: [ currentBlock getPoints notNil									ifTrue: [ self move: line ] ].						line size asString asSymbol == '1' asSymbol							ifTrue: [ self placeBlock: currentBlock at: currentBlock getPoints.								currentBlock setFro ] ] ].		'dice' asSymbol == test			ifTrue: [ dice := Dice new.				dice initialize: line.				self dice ] ].	currentBlock notNil		ifTrue: [ currentBlock getFro				ifFalse: [ movesStat & currentBlock getPoints notNil						ifTrue: [ self placeBlock: currentBlock at: currentBlock getPoints ] ] ]! !!Game methodsFor: 'board' stamp: 'HajeKanda 10/10/2017 02:28'!shift: row	"will move all the rows down by one"	row + 1 to: 2 by: 1 negated do: [ :j | 		2 to: board getCol - 1 do: [ :i | 			(board getRow: j - 1 col: i) asSymbol == 'x' asSymbol				ifFalse: [ board put: (board getRow: j - 1 col: i) row: j col: i ].			(board getRow: j - 1 col: i) asSymbol == 'x' asSymbol				ifTrue: [ board put: ' ' row: j col: i ] ] ].	2 to: board getCol - 1 do: [ :i | board put: ' ' row: 1 col: i ].	puCurrent notNil		ifTrue: [ self checkIfPowerUp.			self placePowerUp ]! !!Game methodsFor: 'board' stamp: 'HajeKanda 10/8/2017 14:51'!boardStart	"comment stating purpose of message"	|temp x|temp := commands at:1.x:=( (temp at:2) asNumber).((x\\2) == 1) ifTrue: [ startNumber := (x//2)+2] .((x\\2) == 0) ifTrue: [ startNumber := (x//2)+1] .! !!Game methodsFor: 'board' stamp: 'HajeKanda 10/8/2017 21:04'!board	"creates the board"			board := Board new.board := (board boardComponents: commands).movesStat := false.self boardStart.! !!Game methodsFor: 'printing' stamp: 'HajeKanda 10/11/2017 10:05'!printOn: display"will print the resulting board"	board printOn: display! !!Game methodsFor: 'check' stamp: 'HajeKanda 10/10/2017 02:26'!onPowerup"will check to see if any of the squares of the current block is on the powerup"	| powerList blockPoints key temp temp2 |	powerList := puCurrent getList.	blockPoints := currentBlock getPoints.	key := false.	1 to: powerList size do: [ :i | 		temp2 := powerList at: i.		1 to: blockPoints size do: [ :j | 			temp := blockPoints at: j.			(temp2 at: 1) asString asSymbol == (temp at: 1) asString asSymbol				& ((temp2 at: 2) asString asSymbol == (temp at: 2) asString asSymbol)				ifTrue: [ key := true ] ] ].	key		ifTrue: [ self powerClear ]! !!Game methodsFor: 'check' stamp: 'HajeKanda 10/10/2017 02:23'!ifFilledRow	"will return true if the row is full"	| temp array tempA |	array := OrderedCollection new.	1 to: currentBlock getTempP size do: [ :i | 		temp := currentBlock getTempP at: i.		' ' asSymbol == (board getRow: (temp at: 1) col: (temp at: 2)) asSymbol			| ('x' asSymbol == (board getRow: (temp at: 1) col: (temp at: 2)) asSymbol)			ifFalse: [ array add: true ].		' ' asSymbol == (board getRow: (temp at: 1) col: (temp at: 2)) asSymbol			| ('x' asSymbol == (board getRow: (temp at: 1) col: (temp at: 2)) asSymbol)			ifTrue: [ array add: false ] ].	tempA := array reject: [ :each | each == true ].	tempA size == array size		ifTrue: [ currentBlock setPoints: currentBlock getTempP.			^ 't' ].	tempA size == array size		ifFalse: [ ^ 'f' ]! !!Game methodsFor: 'check' stamp: 'HajeKanda 10/10/2017 02:24'!isTop	"will move down the new block until it doesnt hit the top of the board"	| tempA tempB |	tempB := currentBlock getTempP.	tempA := tempB select: [ :a | (a at: 1) < 1 ].	tempA isEmpty		ifFalse: [ currentBlock move: '.t'.			tempB := currentBlock getTempP.			tempA := tempB select: [ :a | (a at: 1) < 1 ].			tempA isEmpty				ifFalse: [ currentBlock move: '.t' ] ].	self ifFilledRow! !!Game methodsFor: 'check' stamp: 'HajeKanda 10/12/2017 09:38'!checkIfPowerUp	| powerList key temp2 temp1 |	powerList := puCurrent getList.	key := false.	1 to: powerList size do: [ :i | 		temp2 := powerList at: i.		temp1 := board getRow: (temp2 at: 1) col: (temp2 at: 2).		temp1 asString asSymbol ~= 'x' asSymbol			ifTrue: [ temp1 asString asSymbol ~= ' ' asSymbol					ifTrue: [ key := true ] ] ].	key		ifTrue: [ 			self powerClear ]! !!Game methodsFor: 'readFrom' stamp: 'HajeKanda 10/10/2017 02:28'!readFrom: string	"breaks up the input and places it within an array"	| message list x |	list := OrderedCollection new.	message := ReadStream on: string.	[ message atEnd ]		whileFalse: [ x := message nextLine.			list add: x ].	commands := list.	self componenter.	self board.	self commands! !!Game methodsFor: 'componeter' stamp: 'HajeKanda 9/29/2017 10:44'!componenter	"will break up the collection to a collection of an array of words	will update commands so it is now 	Collection(Collection('board' '8' '8') Collection('powerup' '8' '4') Collection('dice' '1' '2' )) etc"|temp| 1 to: (commands size) do: [  :i | 		temp:= (commands at: i).		temp := temp splitOn: ' '.		commands at: i put: temp.].! !TestCase subclass: #GameTest	instanceVariableNames: 'game'	classVariableNames: ''	poolDictionaries: ''	category: 'Assignment'!!GameTest methodsFor: 'tests' stamp: 'HajeKanda 10/8/2017 14:57'!testSimpleOddWidth|input output|input := game readFrom: 'board 7 6dice 3 1moves'.output:='|   gg  | 1 piece|  gg   ||       ||       ||       ||       |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 7 6dice 3 2moves'.output :='|   g   | 1 piece|   gg  ||    g  ||       ||       ||       |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 7 6dice 3 1moves R'.output :='|   g   | 1 piece|   gg  ||    g  ||       ||       ||       |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 7 10dice 1 2 7 2 2moves +'.output :='|   c   | 2 pieces|   c   ||   c   ||   c   ||       ||       ||       ||       ||   yy  ||   yy  |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 7 10dice 1 1 7 1 2moves +'.output:='|  cccc | 2 pieces|       ||       ||       ||       ||       ||       ||       ||   yy  ||   yy  |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 7 10dice 1 2 7 2 2moves ++'.output:='|  rr   | 3 pieces|   rr  ||       ||       ||   c   ||   c   ||   c   ||   c   ||   yy  ||   yy  |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 7 10powerup 2 9dice 1 2 7 2 2moves ll llmoves +..'.output:='|       | 2 pieces| x     ||   c   ||   c   ||   c   ||   c   ||       ||       ||yy     ||yy     |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).! !!GameTest methodsFor: 'tests' stamp: 'HajeKanda 10/10/2017 01:01'!testMoves	| input output |	self setUp.	input := game		readFrom:			'board 7 8dice 1 1moves l'.	output := '|  yy   | 1 piece|  yy   ||       ||       ||       ||       ||       ||       |+-------+'.	self assert: (String streamContents: [ :s | game printOn: s ]) equals: output asString.	self setUp.	input := game		readFrom:			'board 7 8dice 1 1moves r'.	output := '|    yy | 1 piece|    yy ||       ||       ||       ||       ||       ||       |+-------+'.	self assert: (String streamContents: [ :s | game printOn: s ]) equals: output asString.	self setUp.	input := game		readFrom:			'board 7 8dice 1 1moves r r r'.	output := '|     yy| 1 piece|     yy||       ||       ||       ||       ||       ||       |+-------+'.	self assert: (String streamContents: [ :s | game printOn: s ]) equals: output asString.	self setUp.	input := game		readFrom:			'board 7 8dice 1 1moves l l l l l'.	output := '|yy     | 1 piece|yy     ||       ||       ||       ||       ||       ||       |+-------+'.	self assert: (String streamContents: [ :s | game printOn: s ]) equals: output asString.	self setUp.	input := game		readFrom:			'board 7 8dice 2 1moves L l ll L'.	output := '| r     | 1 piece|rr     ||r      ||       ||       ||       ||       ||       |+-------+'.	self assert: (String streamContents: [ :s | game printOn: s ]) equals: output asString.	self setUp.	input := game		readFrom:			'board 7 8dice 6 2moves l ll L'.	output := '|p      | 1 piece|pp     ||p      ||       ||       ||       ||       ||       |+-------+'.	self assert: (String streamContents: [ :s | game printOn: s ]) equals: output asString.					self setUp.	input := game		readFrom:			'board 7 8dice 1 1 1 1 1 7 2moves r+r+r+ RR'.	output := '|    r  | 4 pieces|   rr  ||   ryy ||    yy ||    yy ||    yy ||    yy ||    yy |+-------+'.	self assert: (String streamContents: [ :s | game printOn: s ]) equals: output asString.				"-------------------------------WORKS UNTIL HERE--------------------------"	self setUp.	input := game		readFrom:			'board 7 8dice 1 1moves ++++l rmoves lRL'.	output := '|   yy  | 4 pieces|   yy  ||   yy  ||   yy  ||   yy  ||   yy  ||   yy  ||   yy  |+-------+'.	self assert: (String streamContents: [ :s | game printOn: s ]) equals: output asString! !!GameTest methodsFor: 'tests' stamp: 'HajeKanda 10/8/2017 14:53'!testSimpleEvenWidth|input output|input := game readFrom: 'board 8 6dice 3 1moves'.output:='|   gg   | 1 piece|  gg    ||        ||        ||        ||        |+--------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 8 6dice 3 2moves'.output :='|   g    | 1 piece|   gg   ||    g   ||        ||        ||        |+--------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 8 6dice 3 1moves R'.output :='|   g    | 1 piece|   gg   ||    g   ||        ||        ||        |+--------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 8 10dice 1 2 7 2 2moves +'.output :='|   c    | 2 pieces|   c    ||   c    ||   c    ||        ||        ||        ||        ||   yy   ||   yy   |+--------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 8 10dice 1 1 7 1 2moves +'.output:='|  cccc  | 2 pieces|        ||        ||        ||        ||        ||        ||        ||   yy   ||   yy   |+--------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 8 10dice 1 2 7 2 2moves + +'.output:='|  rr    | 3 pieces|   rr   ||        ||        ||   c    ||   c    ||   c    ||   c    ||   yy   ||   yy   |+--------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 8 10powerup 2 9dice 1 2 7 2 2moves ll llmoves +..'.output:='|        | 2 pieces| x      ||   c    ||   c    ||   c    ||   c    ||        ||        ||yy      ||yy      |+--------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).! !!GameTest methodsFor: 'tests' stamp: 'HajeKanda 10/9/2017 19:22'!testPowerUp|input output|self setUp.												input := game readFrom: 'board 7 8dice 1 1powerup 1 6moves lll+l+r+lll+moves lll+'.output:='|   yy  | 6 pieces|   yy  ||x      ||yy     ||yy     ||yy     ||yy     ||yyyyyy |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 7 8dice 1 1powerup 1 6powerup 2 7moves lll+l+r+lll+moves lll+'.output:='|   yy  | 6 pieces| x yy  ||x      ||yy     ||yy     ||yy     ||yy     ||yyyyyy |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.											input := game readFrom: 'board 7 8dice 1 1powerup 1 6moves ll+l+r+lll+ r+moves lll+'.output:='|   yy  | 7 pieces|   yy  ||x      ||yy     ||yy     ||yyyyyy || yy yy || yy yy |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 7 8dice 1 1powerup 2 5moves lll+l+r+lll+moves lll+'.output:='|   yy  | 6 pieces|   yy  ||       || x     ||yy     ||yy     ||yy     ||yy     |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 7 8dice 1 1powerup 2 4moves lll+l+r+lll+moves lll+'.output:='|   yy  | 6 pieces|   yy  ||       ||       ||yy     ||yy     ||yy     ||yy     |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).! !!GameTest methodsFor: 'tests' stamp: 'HajeKanda 10/8/2017 18:55'!testFullRow|input output|self setUp.input := game readFrom: 'board 8 4dice 1 1 1 1moves lll+l+r+rrr+'.output:='|   yy   | 5 pieces|   yy   ||        ||yyyyyyyy|+--------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 8 4dice 1 1moves lll+l+r+rrr+'.output:='|   yy   | 5 pieces|   yy   ||        ||yyyyyyyy|+--------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 8 5dice 1 1 1 1moves lll+l+r+lll+rrr+'.output:='|   yy   | 6 pieces|   yy   ||yy      ||yy      ||yyyyyyyy|+--------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).! !!GameTest methodsFor: 'tests' stamp: 'HajeKanda 10/8/2017 22:02'!testRotations|input output|"-------------------------shape y---------------------------------"self setUp.input := game readFrom: 'board 6 4dice 1 1moves'.output:='|  yy  | 1 piece|  yy  ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).'board 6 4dice 1 2moves'.output:='|  yy  | 1 piece|  yy  ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).'board 6 4dice 1 3moves'.output:='|  yy  | 1 piece|  yy  ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).'board 6 4dice 1 4moves'.output:='|  yy  | 1 piece|  yy  ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString)."-------------------------shape r---------------------------------"self setUp.input := game readFrom: 'board 6 4dice 2 1moves'.output:='| rr   | 1 piece|  rr  ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 2 2moves'.output:='|   r  | 1 piece|  rr  ||  r   ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 2 3moves'.output:='| rr   | 1 piece|  rr  ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 2 4moves'.output:='|   r  | 1 piece|  rr  ||  r   ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString)."-------------------------shape g---------------------------------"self setUp.input := game readFrom: 'board 6 4dice 3 1moves'.output:='|  gg  | 1 piece| gg   ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 3 2moves'.output:='|  g   | 1 piece|  gg  ||   g  ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 3 3moves'.output:='|  gg  | 1 piece| gg   ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 3 4moves'.output:='|  g   | 1 piece|  gg  ||   g  ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString)."-------------------------shape b---------------------------------"self setUp.input := game readFrom: 'board 6 4dice 4 1moves'.output:='| b    | 1 piece| bbb  ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 4 2moves'.output:='|  bb  | 1 piece|  b   ||  b   ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 4 3moves'.output:='| bbb  | 1 piece|   b  ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 4 4moves'.output:='|  b   | 1 piece|  b   || bb   ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString)."-------------------------shape o---------------------------------"self setUp.input := game readFrom: 'board 6 4dice 5 1moves'.output:='|   o  | 1 piece| ooo  ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 5 2moves'.output:='|  o   | 1 piece|  o   ||  oo  ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 5 3moves'.output:='| ooo  | 1 piece| o    ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 5 4moves'.output:='| oo   | 1 piece|  o   ||  o   ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString)."-------------------------shape p---------------------------------"self setUp.input := game readFrom: 'board 6 4dice 6 1moves'.output:='|  p   | 1 piece| ppp  ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 6 2moves'.output:='|  p   | 1 piece|  pp  ||  p   ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 6 3moves'.output:='| ppp  | 1 piece|  p   ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 6 4moves'.output:='|  p   | 1 piece| pp   ||  p   ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString)."-------------------------shape c---------------------------------"self setUp.input := game readFrom: 'board 6 4dice 7 1moves'.output:='| cccc | 1 piece|      ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 7 2moves'.output:='|  c   | 1 piece|  c   ||  c   ||  c   |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 7 3moves'.output:='|cccc  | 1 piece|      ||      ||      |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).input := game readFrom: 'board 6 4dice 7 4moves'.output:='|  c   | 1 piece|  c   ||  c   ||  c   |+------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).! !!GameTest methodsFor: 'tests' stamp: 'HajeKanda 10/10/2017 01:47'!testSimpleEmpty|input output|self setUp.input := game readFrom: 'board 7 4'.output:='|       | 0 pieces|       ||       ||       |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 8 6'.output:='|        | 0 pieces|        ||        ||        ||        ||        |+--------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 7 4powerup 3 3dice 1 1powerup 2 1'.output:='|       | 0 pieces|  x    ||       || x     |+-------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).self setUp.input := game readFrom: 'board 8 5powerup 1 5dice 1 1'.output:='|x       | 0 pieces|        ||        ||        ||        |+--------+'.self assert: (String streamContents: [: s | game printOn: s]) equals: (output asString).! !!GameTest methodsFor: 'setUp' stamp: 'HajeKanda 10/8/2017 11:35'!setUpsuper setUp.game := Game new.! !Blocks subclass: #O	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Assignment'!!O commentStamp: 'HajeKanda 10/11/2017 10:06' prior: 0!Creates the subclass block O with more specific methods!!O methodsFor: 'initialize' stamp: 'HajeKanda 10/10/2017 02:11'!initializex: b y: a	| p1 p2 p3 p4 |	"creates the block"	super initializex: a y: b.	type := 'o'.	p1 := Array with: a with: b.	p2 := Array with: a with: b + 1.	p3 := Array with: a with: b - 1.	p4 := Array with: a - 1 with: b + 1.	self		setTempP:			(Array				with: p1				with: p2				with: p3				with: p4).	^ points! !!O methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:05'!move: dir	"chooses the correct action and deals accordingly"	dir asString asSymbol == 'l' asSymbol		ifTrue: [ self left ].	dir asString asSymbol == 'r' asSymbol		ifTrue: [ self right ].	dir asString asSymbol == 'L' asSymbol		ifTrue: [ orient asString asSymbol == '1' asSymbol				ifTrue: [ orient := 5 ].			orient asString asSymbol == '1' asSymbol				ifFalse: [ self rotate: orient - 1 ] ].	dir asString asSymbol == 'R' asSymbol		ifTrue: [ orient asString asSymbol == '4' asSymbol				ifTrue: [ orient := 0 ].			orient asString asSymbol == '4' asSymbol				ifFalse: [ self rotate: orient + 1 ] ].	dir asString asSymbol == '.' asSymbol		ifTrue: [ super down ].	dir asString asSymbol == '.t' asSymbol		ifTrue: [ super tempDown ].	dir asString asSymbol == 'up' asSymbol		ifTrue: [ self up ]! !!O methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:07'!rotate: cw	"rotates the block according to its orientation"	| p1 p2 p3 p4 coord |	coord := points at: 1.	column := coord at: 1.	row := coord at: 2.	p1 := Array with: column with: row.	1 == cw		ifTrue: [ p2 := Array with: column with: row + 1.			p3 := Array with: column with: row - 1.			p4 := Array with: column - 1 with: row + 1.			orient := 1 asInteger ].	2 == cw		ifTrue: [ p2 := Array with: column - 1 with: row.			p3 := Array with: column + 1 with: row.			p4 := Array with: column + 1 with: row + 1.			orient := 2 asNumber ].	3 == cw		ifTrue: [ p2 := Array with: column with: row + 1.			p3 := Array with: column with: row - 1.			p4 := Array with: column + 1 with: row - 1.			orient := 3 asNumber ].	4 == cw		ifTrue: [ p2 := Array with: column - 1 with: row - 1.			p3 := Array with: column + 1 with: row.			p4 := Array with: column - 1 with: row.			orient := 4 asNumber ].	self		setTempP:			(Array				with: p1				with: p2				with: p3				with: p4).	^ points! !Blocks subclass: #P	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Assignment'!!P commentStamp: 'HajeKanda 10/11/2017 10:06' prior: 0!Creates the subclass block P with more specific methods!!P methodsFor: 'initialize' stamp: 'HajeKanda 10/10/2017 02:11'!initializex: b y: a	"creates the block"	| p1 p2 p3 p4 |	super initializex: a y: b.	type := 'p'.	p1 := Array with: a with: b.	p2 := Array with: a with: b + 1.	p3 := Array with: a with: b - 1.	p4 := Array with: a - 1 with: b.	self		setTempP:			(Array				with: p1				with: p2				with: p3				with: p4).	^ points! !!P methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:05'!move: dir	"chooses the correct action and deals accordingly"	dir asString asSymbol == 'l' asSymbol		ifTrue: [ self left ].	dir asString asSymbol == 'r' asSymbol		ifTrue: [ self right ].	dir asString asSymbol == 'L' asSymbol		ifTrue: [ orient asString asSymbol == '1' asSymbol				ifTrue: [ orient := 5 ].			orient asString asSymbol == '1' asSymbol				ifFalse: [ self rotate: orient - 1 ] ].	dir asString asSymbol == 'R' asSymbol		ifTrue: [ orient asString asSymbol == '4' asSymbol				ifTrue: [ orient := 0 ].			orient asString asSymbol == '4' asSymbol				ifFalse: [ self rotate: orient + 1 ] ].	dir asString asSymbol == '.' asSymbol		ifTrue: [ super down ].	dir asString asSymbol == '.t' asSymbol		ifTrue: [ super tempDown ].	dir asString asSymbol == 'up' asSymbol		ifTrue: [ self up ]! !!P methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:07'!rotate: cw	"rotates the block according to its orientation"	| p1 p2 p3 p4 coord |	coord := points at: 1.	column := coord at: 1.	row := coord at: 2.	p1 := Array with: column with: row.	1 == cw		ifTrue: [ p2 := Array with: column with: row + 1.			p3 := Array with: column with: row - 1.			p4 := Array with: column - 1 with: row.			orient := 1 asInteger ].	2 == cw		ifTrue: [ p2 := Array with: column - 1 with: row.			p3 := Array with: column + 1 with: row.			p4 := Array with: column with: row + 1.			orient := 2 asNumber ].	3 == cw		ifTrue: [ p2 := Array with: column with: row - 1.			p3 := Array with: column + 1 with: row.			p4 := Array with: column with: row + 1.			orient := 3 asNumber ].	4 == cw		ifTrue: [ p2 := Array with: column - 1 with: row.			p3 := Array with: column with: row - 1.			p4 := Array with: column + 1 with: row.			orient := 4 asNumber ].	self		setTempP:			(Array				with: p1				with: p2				with: p3				with: p4).	^ points! !Object subclass: #PowerUp	instanceVariableNames: 'type points list'	classVariableNames: ''	poolDictionaries: ''	category: 'Assignment'!!PowerUp commentStamp: 'HajeKanda 10/11/2017 10:08' prior: 0!Creates the powerup and its location!!PowerUp methodsFor: 'initialize' stamp: 'HajeKanda 10/10/2017 02:17'!startList"stats the list of powerups"	list := OrderedCollection new! !!PowerUp methodsFor: 'initialize' stamp: 'HajeKanda 10/10/2017 02:17'!initializex: b y: a"initialize the powerup"	| p1 |	type := 'x'.	p1 := Array with: a with: b.	self addToList: p1.	^ points! !!PowerUp methodsFor: 'initialize' stamp: 'HajeKanda 10/10/2017 02:17'!setPoints: p"sets the point of the powerup"	points := p! !!PowerUp methodsFor: 'accessor' stamp: 'HajeKanda 10/10/2017 02:16'!getList"returns the list of powerups"	^ list! !!PowerUp methodsFor: 'accessor' stamp: 'HajeKanda 10/10/2017 02:16'!getPoints"returns the points of the single power up"	^ points! !!PowerUp methodsFor: 'accessor' stamp: 'HajeKanda 10/10/2017 02:16'!getType"returns type powerup"	^ type! !!PowerUp methodsFor: 'adding' stamp: 'HajeKanda 10/10/2017 02:16'!addToList: coord"adds to the list of powerups"	list add: coord! !Blocks subclass: #R	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Assignment'!!R commentStamp: 'HajeKanda 10/11/2017 10:06' prior: 0!Creates the subclass block R with more specific methods!!R methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:05'!move: dir	"chooses the correct action and deals accordingly"	dir asString asSymbol == 'l' asSymbol		ifTrue: [ self left ].	dir asString asSymbol == 'r' asSymbol		ifTrue: [ self right ].	dir asString asSymbol == 'L' asSymbol		ifTrue: [ orient asString asSymbol == '1' asSymbol				ifTrue: [ orient := 5 ].			orient asString asSymbol == '1' asSymbol				ifFalse: [ self rotate: orient - 1 ] ].	dir asString asSymbol == 'R' asSymbol		ifTrue: [ orient asString asSymbol == '4' asSymbol				ifTrue: [ orient := 0 ].			orient asString asSymbol == '4' asSymbol				ifFalse: [ self rotate: orient + 1 ] ].	dir asString asSymbol == '.' asSymbol		ifTrue: [ super down ].	dir asString asSymbol == '.t' asSymbol		ifTrue: [ super tempDown ].	dir asString asSymbol == 'up' asSymbol		ifTrue: [ self up ]! !!R methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:07'!rotate: cw	"rotates the block according to its orientation"	| p1 p2 p3 p4 coord |	coord := points at: 1.	column := coord at: 1.	row := coord at: 2.	p1 := Array with: column with: row.	1 == cw		ifTrue: [ p2 := Array with: column with: row + 1.			p3 := Array with: column - 1 with: row.			p4 := Array with: column - 1 with: row - 1.			orient := 1 asInteger ].	2 == cw		ifTrue: [ p2 := Array with: column with: row + 1.			p3 := Array with: column + 1 with: row.			p4 := Array with: column - 1 with: row + 1.			orient := 2 asNumber ].	3 == cw		ifTrue: [ p2 := Array with: column with: row - 1.			p3 := Array with: column + 1 with: row + 1.			p4 := Array with: column + 1 with: row.			orient := 3 asNumber ].	4 == cw		ifTrue: [ p2 := Array with: column + 1 with: row.			p3 := Array with: column with: row + 1.			p4 := Array with: column - 1 with: row + 1.			orient := 4 asNumber ].	self		setTempP:			(Array				with: p1				with: p2				with: p3				with: p4).	^ points! !!R methodsFor: 'initialize' stamp: 'HajeKanda 10/10/2017 02:11'!initializex: b y: a	"creates the block"	| p1 p2 p3 p4 |	super initializex: a y: b.	type := 'r'.	p1 := Array with: a with: b.	p2 := Array with: a with: b + 1.	p3 := Array with: a - 1 with: b.	p4 := Array with: a - 1 with: b - 1.	self		setTempP:			(Array				with: p1				with: p2				with: p3				with: p4).	^ points! !Blocks subclass: #Y	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Assignment'!!Y commentStamp: 'HajeKanda 10/11/2017 10:06' prior: 0!Creates the subclass block Y with more specific methods!!Y methodsFor: 'initialize' stamp: 'HajeKanda 10/10/2017 02:10'!initializex: b y: a	"creates the block"	| p1 p2 p3 p4 |	super initializex: a y: b.	type := 'y'.	p1 := Array with: a with: b.	p2 := Array with: a with: b + 1.	p3 := Array with: a - 1 with: b.	p4 := Array with: a - 1 with: b + 1.	self		setTempP:			(Array				with: p1				with: p2				with: p3				with: p4).	^ points! !!Y methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:05'!move: dir	"chooses the correct action and deals accordingly"	dir asString asSymbol == 'l' asSymbol		ifTrue: [ self left ].	dir asString asSymbol == 'r' asSymbol		ifTrue: [ self right ].	dir asString asSymbol == 'L' asSymbol		ifTrue: [ orient asString asSymbol == '1' asSymbol				ifTrue: [ orient := 5 ].			orient asString asSymbol == '1' asSymbol				ifFalse: [ self rotate: orient - 1 ] ].	dir asString asSymbol == 'R' asSymbol		ifTrue: [ orient asString asSymbol == '4' asSymbol				ifTrue: [ orient := 0 ].			orient asString asSymbol == '4' asSymbol				ifFalse: [ self rotate: orient + 1 ] ].	dir asString asSymbol == '.' asSymbol		ifTrue: [ super down ].	dir asString asSymbol == '.t' asSymbol		ifTrue: [ super tempDown ].	dir asString asSymbol == 'up' asSymbol		ifTrue: [ self up ]! !!Y methodsFor: 'modifier' stamp: 'HajeKanda 10/10/2017 02:12'!rotate: cw"doesnt rotate since the square is the same anyways"	^ points! !
